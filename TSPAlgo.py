import math
import turtle
import random
import TSP
import itertools
import time

smallgraphverts = ["α", "β", "γ", "δ", "ε", "ζ"]
mediumgraphverts = ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
largegraphverts = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"]

def singletest(algoname, GraphObj, StartVertName, CycleBool):
    # Method intended to test the accuracy/reliability of TSP algorithms and heuristics.

    BFP = BruteForce(GraphObj, StartVertName, CycleBool)
    BFPCost  = GraphObj.PathWeight(BFP, False)
    AlgoP = None
    AlgoCost = 0
    resultdouble = (None, None)

    # Run the specified algorithm and compare the total cost of the path it generates to 
    # the "optimal" path found via brute force for the given graph.

    # The second value of "resultdouble" is the difference in length between the path generated via
    # The specified algorithm and the length of the optimal path. If the optimal path is equal in length
    # to that generated by the specified algorithm, the first value will be "True". Otherwise,
    # the first value will be "False".

    if str(algoname).lower() == "nn" or str(algoname).lower() == "nearest neighbor":
        AlgoP = NearestNeighbor(GraphObj, StartVertName, CycleBool)
        AlgoCost = GraphObj.PathWeight(AlgoP, False)

    if str(algoname).lower() == "ni" or str(algoname).lower() in ["nearest insertion", "nearest insert"]:
        AlgoP = NearestInsert(GraphObj, StartVertName, CycleBool)
        AlgoCost = GraphObj.PathWeight(AlgoP, False)
    
    if BFPCost == AlgoCost:
        resultdouble = (True, 0.0)
    else:
        resultdouble = (False, AlgoCost - BFPCost)

    return resultdouble


def itertest(algoname, VertNameList, StartVertName, iter, CycleBool):
    # Method intended to test the accuracy/reliability of TSP algorithms and heuristics iteratively.
    # By the Law of Large Numbers, the success rate will more closely reflect how accurate the algorithm
    # is the larger "iter" is. 

    # Run the algorithm specified "iter" times using randomly generated graphs.
    # Each time we run the algorithm, get the cost of the path/cycle it generates
    # and compare it to the "brute force" result. We assume the brute force algorithm
    # will always produce an optimal result for any given graph. 

    successnum = 0
    successrat = 0
    successperc = 0

    for i in range(0, iter):
        GraphName = "Graph " + str(i)
        G = TSP.TSPGraph(10, GraphName)
        G.Clear()
        G.PopulateRandom(VertNameList)

        trial = singletest(algoname, G, StartVertName, CycleBool)
        
    # If the resulting algorithm produces a path of equal cost equal to optimal result, we consider it
    # a "success" and increment the "success" counter by 1. Otherwise, we consider it a 
    # "failure" and do not increment. We can use this to get a rough idea of how "accurate"
    # the given heuristic is in terms of getting us an optimal solution.

        if trial[0] == True:
            successnum +=1
    
    successrat = successnum/iter
    successperc = successrat*100

    return(successnum, successrat, successperc, iter)

def testreport(testtuple, testname):
    # print the results of an itertest trial to the screen. 
    # takes the tuple (successnum, successrate, sucessperc, numtestsran) as input.

    if testtuple != None and len(testtuple) == 4 and testname != None:
        successnum = testtuple[0]
        successrate = testtuple[1]
        successperc = testtuple[2]
        numtests = testtuple[3]

        print("\n Tests results for ", testname, ":")

        if numtests != None:
            print("Number of tests ran: ", numtests)

        if successnum != None:
            print("Number of successful outcomes: ", successnum)

        if successrate != None:
            print("Success rate: ", successrate)

        if successperc != None:
            print("Success percentage: ", successperc)

        if numtests != None and successnum != None:
            print("Success ratio: ", successnum, "/", numtests)


def algotest(graphvertices, startvert, cyclebool):
    # Method intended to test if each algorithm is working properly.

    # Generate a randomized graph with vertex names as follows:
    R = RandomGraph(graphvertices)
    # Print the cost/distance matrix for the randomized graph. We can use this to
    # represent our "distance function"
    print("Cost matrix for randomized graph R:")
    for r in R.CostMatrix(True):
        print(str(r))

    BFP = BruteForce(R, startvert, cyclebool)
    print("\n Brute Force Path Result:", BFP)
    print("Total Path Weight:", R.PathWeight(BFP, True))

    NNP = NearestNeighbor(R, startvert, cyclebool)
    print("\n Nearest Neighbor Path Result:", NNP)
    print("Total Path Weight:", R.PathWeight(NNP, True))

    NIP = NearestInsert(R, startvert, cyclebool)
    print("\n Nearest Insertion Path Result:", NIP)
    print("Total Path Weight:", R.PathWeight(NIP, True))

    PathDict = {"Brute Force": BFP, "Nearest Neighbor": NNP, "Nearest Insertion": NIP}

    TSP.TracePaths(R, PathDict, False, True, True)

def RandomGraph(NameSet):
    # Generate a random graph with vertex names from the set "NameSet".
    # A TSP graph with bound 10 has 100 possible unique points, so
    # such a bound value should be sufficient for our purposes.
    RGraph = TSP.TSPGraph(10, "Randomized Graph")
    RGraph.PopulateRandom(NameSet)

    return RGraph

def BruteForce(GraphObj, StartVertName, CycleBool):
    # Check every unique path originating from the starting vertex, then
    # compare them to find the shortest one. Guarenteed to find an exact answer,
    # but computationally inefficient (O(n!) time completixty). If CycleBool == True, 
    # include the edge that gets us back to our starting vertex.
    finalpath = None
    pathdict = {}
    pathlist =[]
    GraphVertexNames = GraphObj.GetVertexNames()
    GraphVertexNames.remove(StartVertName)

    for p in itertools.permutations(GraphVertexNames):
        # Get every unique path in the graph starting at the specified vertex.
        # Add the starting vertex to the end of the path if neccessary to make it a cycle.
        patharray = [StartVertName]
        for t in p:
            patharray.append(t)

        if CycleBool == True:
            patharray.append(StartVertName)

        if patharray not in pathlist:
            pathlist.append(patharray)
            

    for i in range(0, len(pathlist)):
        # Get the length (total weight) of every path in pathlist
        currentpath = pathlist[i]
        pathlength = GraphObj.PathWeight(currentpath, False)
        pathdict[i] = pathlength

    # Return the path with the shortest length as our finalpath
    finalpath = pathlist[min(pathdict, key=pathdict.get)]

    return finalpath

def NearestNeighbor(GraphObj, StartVertName, CycleBool):
    # Implementation of the "nearest neighbor" algorithm as described in Rosenkratz's paper.
    # Easy to implement and relatively fast, but doesn't always produce an optimal solution.
    # If CycleBool == True, include the edge that gets us back to our starting vertex.
    finalpath = []
    VisitedVertices = []
    CurrentVert = None
    PreviousVert = None
    GraphVertexNames = GraphObj.GetVertexNames()

    if GraphObj.NameInGraph(StartVertName) == True:
        CurrentVert = StartVertName
        finalpath.append(StartVertName)
        for V in GraphVertexNames:
            if len(finalpath) < len(GraphVertexNames):
                VisitedVertices.append(CurrentVert)
                VertDistances = {}
                SortedDistances = {}

            # Get the distances between the current vertex and every other vertex in the graph.
            # Here, we make the distance between any vertex and itself an arbitarily high value.
            # If a vertex has already been visited, we also make it an arbitrarily high value.
                for W in GraphVertexNames:
                    if CurrentVert == W or W in VisitedVertices:
                        VertDistances[W] = 999999
                    else:
                        VertDistances[W] = GraphObj.GetDistance(CurrentVert, W, False)
                
            
                SortedDistances = dict(sorted(VertDistances.items(), key=lambda item: item[1]))
                PreviousVert = CurrentVert

                if len(SortedDistances) > 0:
                    CurrentVert = min(SortedDistances, key=SortedDistances.get)
                    finalpath.append(CurrentVert)

                else:
                    for X in GraphVertexNames:
                        if X in finalpath:
                            GraphVertexNames.remove(X)
                            
        if CycleBool == True:
            finalpath.append(StartVertName)

    return finalpath

def NearestInsert(GraphObj, StartVertName, CycleBool):
    # Start with the starting vertex. At each step of the process, add
    # to our "final path" the vertex with the lowest distance to any vertex
    # already in our "final path". Repeat this until every vertex in the graph
    # has been visited once. If CycleBool == True, add the starting vertex to the
    # end of our path so it becomes a cycle.
    finalpath = []
    
    GraphVertices = GraphObj.GetVertexNames()
    UnvisitedVertices = GraphObj.GetVertexNames()

    if GraphObj.NameInGraph(StartVertName) == True:
        finalpath.append(StartVertName)
        UnvisitedVertices.remove(StartVertName)

        while len(UnvisitedVertices) > 0:
            vertexdistances = []
            closestvertdict = {}
        # Each time we visit a vertex, we remove it from our list of unvisited vertices. Do the following
        # until no vertices are unvisited:
            for v in finalpath:
                distdict = {}
        # Construct dictionaries for each vertex in our final path using the distance between said vertec
        # and every other vertex in the graph.
                for w in GraphVertices:
                    if w not in finalpath:
                        distdict[w] = GraphObj.GetDistance(v, w, False)
                    
                vertexdistances.append(distdict)
        # Take the vertex which is closest to any vertex in our "final path" and add it to our path.
        # Remove it from the list of unvisited vertices
                closestvert = min(distdict, key=distdict.get)
                closestvertdict[closestvert] = distdict[closestvert]

            mindist = min(closestvertdict, key=distdict.get)

            UnvisitedVertices.remove(mindist)
            finalpath.append(mindist)

    if CycleBool == True:
        finalpath.append(StartVertName)

    return finalpath

def GenMinTree(GraphObj, StartVertName, drawtree):
    # Generates a minimum spanning tree for a given graph starting from a given vertex.
    # The tree generation algorithm used is an implementation of Prim's algorithm.
    MinTree = None
    NameString = "MinTree-",GraphObj.GetName(),"-",StartVertName
    if GraphObj.SearchByName(StartVertName) != None:
        MinTree = TSP.MinSpanningTree(GraphObj, StartVertName, NameString)
        MinTree.GenerateMinTree()

        if drawtree:
            TSP.DrawMinTree(GraphObj, MinTree, True, True, "orange")
        
    return MinTree




#RandomSmall = RandomGraph(smallgraphverts)
#RandomMid = RandomGraph(mediumgraphverts)
#I1small = itertest("Nearest Neighbor", smallgraphverts, "A", 10, True)
#I2small = itertest("Nearest Insertion", smallgraphverts, "A", 10, True)
#testreport(I1small, "Nearest Neighbor")
#testreport(I2small, "Nearest Insertion")
algotest(mediumgraphverts, "A", False)
#print(singletest("ni", RandomGraph(smallgraphverts), "ε", True))